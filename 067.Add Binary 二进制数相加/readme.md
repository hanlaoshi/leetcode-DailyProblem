# [647. Palindromic Substrings（马拉车算法）](https://www.cnblogs.com/liaohuiqiang/p/9755379.html)

## Manacher算法

使用马拉车算法，算法根据回文串的对称特点利用之前的信息计算，可以在线性时间内找出所有回文串。

**“原字符串”转为“#字符串”**
前面说了回文串分为单字符中心和双字符中心，为了可以统一按单字符中心处理。首先在原字符中插入字符'#'，例如aaa经过插入处理后得到"#a#a#a#"，这样遍历到第一个a时其实是以a为单字符中心，遍历到第二个#时就是以aa为双字符中心。第一个#和最后一个#的意义在于补全第一个字符和最后一个字符的“回文串身份”，因为单个字符也算回文串。

**镜像计算**
我们用p[i]表示以i为中心的回文串半径，p[i]初始化为0。正常情况，我们根据扩张的方法来判断半径是否增加。
特殊情况，如果字符s[i]处于某个已知的“以id为中心，以mx为右边界”的回文串中（此时mx > i），我们称这个回文串为id回文串，此时可以利用id为中心对称过去的镜像索引来简化计算，我们称镜像索引为j。然后有两种情况。

如果p[j]<mx-i，说明i的半径没有超出mx的边界而且等于j的半径，此时p[i]=[j]=p[2*id-1]，这个p[i]值是确定的。
![img](https://img2018.cnblogs.com/blog/1160281/201810/1160281-20181008164926261-1919165883.png)

如果p[j]>=mx-i，说明i的半径至少扩张到了mx，mx之后的部分要继续扩张。此时p[i]值不是确定的，但是我们让p[i]=mx-i，因为半径为mx-i是至少的，至于半径是否继续增加取决于mx后面的部分，我们在扩张步骤计算。
![img](https://img2018.cnblogs.com/blog/1160281/201810/1160281-20181008164934086-1949485285.png)

简化以上两种情况可以得到：如果mx > i，那么p[i] = min(p[2*id-1], mx-i)

**扩张**
根据上面的说明，只有在mx >i 以及 p[j] < mx-i的情况下可以通过镜像计算来直接获得半径，其它情况还是要继续扩张。扩张的计算很简单，在当前半径的基础上扩张，判断s[i+p[i]+1]和s[i-p[i]-1]是否相等，相等则半径p[i]加1。

**更新id回文串**
遍历过程中，如果发现有右边界更大的回文串，则覆盖这个回文串。

**“#字符串”的回文个数->“原字符串”的回文个数**：
上面计算的半径p[i]会因为#的插入而增多，所以要根据“#字符串”的半径计算一下，得到“原字符串”的半径。我们把所有半径加起来就可以计算出回文字串的数量。

举个双字符为中心的例子，#a#a#，中间#的半径为a#，要转为半径a，2要转为1，直接除以2就得到了。

举个单字符为中心的例子，#a#a#b#a#a#，b的半径#a#a#，要转为半径aa，5要转为2，但是考虑b本身也是一个回文串，实际上是5要转为3，这个时候需要加1之后除以2（这里跟半径的定义有关，我这里的定义中b这个单字符的半径为0。如果定义的b的半径为1，这里的计算就不是加1而是减1了）。

综合来看，直接加1除以2就可以了，因为/会向下取整。

> 时间复杂度O(n)，空间复杂度O(1)

## 2、DP算法

思路

求字符串的回文子串个数。假定子串内容相同但index不同认定为不同得子串。比如：在”aaa”中，共有 “a”, “a”, “a”, “aa”, “aa”, “aaa”六个回文子串，前三个回文 “a”, “a”, “a”就是内容相同但是index分别为0,1,2，所以为不同的子串。 

很明显这是一道dp的题，从左到右遍历字符串，每次加进一个字符，递推公式为dp[i]=dp[i-1]+tmpNum。其中，tmpNum为新加进一个字符后新增加的回文子串的个数。当遍历到index=i时，只要看看在i之前的index j，能否构成substring(j,i+1)的回文子串。最后结果是dp[len-1]+len，其中len为字符串的长度，因为字符串每个字符都为回文子串。